---
title: Reinforcement learning with Projective Simulation
comments: true 
status: proofread
tags: qml, algos
description: This is an algorithm for reinforcement learning where you have an agent modeled with laws of quantum mechanics. 
author:
- 'Alessandro “Scinawa” Luongo'
---


<div class="separator" style="clear: both; text-align: center;"></div>In these days, I had the chance to read about a recent algorithm for (quantum) machine learning. Its name is Projective Simulation (PS), proposed by Briegel and Cuevas [1] in 2012. PS melts together ideas from neural networks (whence takes the idea of a graph-like network of objects to model the used to model the memory used in PS)&nbsp; and reinforcement learning (wherefrom it takes the idea of training the algorithm using rewards and punishments as a function of the environment).&nbsp; PS connect aspects of research such as artificial intelligence, quantum information, and quantum computation.<br /><br /><br />Among the various features that make this algorithm interesting, one of the things I like most is that a steps of PS can be executed on a quantum physical system - such as a quantum computer - even gaining computational efficiency over classical computers using quantum interference [11], or exploiting topological structure of certain kind of graph [12].<br /><br /><br />PS uses a graph-like representation of the memory of an agent. This representation is so general that allows us to think of the neural networks as a <i>physical</i> implementation of the same kind of memory - called episodic and compositional memory -&nbsp; used by PS. In fact, both algorithms share the concepts that any input received is accompanied by a certain spatiotemporal excitation pattern within the nodes of a network, where similar input cause the same excitation. But PS is way more than this...<br /><br /><a name='more'></a><br /><h3>A digression on freedom and information-processing machines</h3><br />PS algorithm was proposed with a broader scope than being a working quantum Machine Learning (ML) algorithm. In fact, PS play a relevant role in the philosophical debate on the existence of free will. Briegel et al. [7], instead of claiming the presence or the absence of free will in mankind, claim that <i>programmable structure, if (a) sufficiently complex and organized, and (b) capable of developing a specific kind of memory, can exhibit behaviors of creativity and free-will</i>.&nbsp; PS, other than competing with other Reinforcement Learning (RL) algorithms, is proposed as a tool: a fundamental <i>information-theoretic concept that can be used to define a notion of freedom (creativity, intelligence), compatible with the laws of physics</i>.<br /><br /><i>If we accept that free will is compatible with physical law, we  also have to accept that it must be possible, in principle, to build a  machine that would exhibit similar forms of freedom as the one we  usually ascribe to humans and certain animals. [7]</i><br /><br /><br />Think of this algorithm as the "proof" of the claims of the authors relatively the existence of complex system exhibiting free will. We will see how with PS we can&nbsp; create agents&nbsp; whose behavior can (hopefully, unarguably) considered by common sense as creative or intelligent.<br /><br /><br />To better understand the design choices behind the algorithm, we will define Intelligence as the capability of an agent to perceive and act on its environment in a way that maximizes its chances of success. Creativity (a manifestation of intelligence) as the capability of an agent to deal with unprecedented situations, and relate a given situation to other conceivable situations [7][1]. Learning is described as a modification of the molecular details of a neural network of an agent due to experience. <br /><br /><br /><i>The definition of learning is purposely similar to what happens in the brain of some animals</i>, as discovered by some recent results in neuroscience [8]. For instance, the behavior of this poor Aplysia <i>can be largely described as a stimulus-reflex circuit, where the structure of the circuit change over time [9]</i>.<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/e/ef/Aplysia_californica.jpg" style="margin-left: auto; margin-right: auto;"><img border="0" height="231" src="https://upload.wikimedia.org/wikipedia/commons/e/ef/Aplysia_californica.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">ECM-like memory animal. </td></tr></tbody></table><br />PS can be used to analyze emerging behavior of an agent under specific conditions, so to test its behavior in simple environments, such as very simple games.<br /><br /><br />Authors remark that PS does not try to:<br /><br />&nbsp;&nbsp;&nbsp; explain how the brain works, nor explain the nature of consciousness, nor explain the nature of human freedom.<br /><br />Let's see what PS <i>is</i> about now.<br /><br /><h3>Key concepts in PS</h3><br />The model of memory used by the intelligent agents in PS is called <i>Episodic and Compositional Memory</i>. ECM is deliberately similar to other notion of memory in other fields of science. Based on the concept of episodic memory, (see this article by Tulving and Ingvar), ECM is basically a stochastic network of clips. We define:<br /><br /><ul><li>&nbsp;&nbsp;&nbsp; <b>percepts</b>:&nbsp; pieces of data that represent information from the outer world. These are the possible inputs of our algorithm. Formally, a percept is a tuple $( s = (s_1, s_2, ...,s_N) \in S $ , where $S$ is the percept space $S_1 \times ... \times S_n$. Each $s_i = 1, ..., |S_i|$.</li><li>&nbsp;&nbsp;&nbsp; <b>actions</b>: actions the agent can perform in the external world. These are represented by tuples in the action (or actuator) space: $a = (a_1, a_2, ..., A_k) \in A = A_1 \times ... A_k$ where $a_k = 1, ... |A_k| $ . Imagine $a_1$ as the state of "doing a jump", $a_2$ the state of "walking" and so on. These are the output of a single call to EC memory.</li><li>&nbsp;&nbsp;&nbsp; <b>clips</b>: these are nodes in the network of EC memory. A clip is meant to represent the fundamental unit of the episodic memory I told you before. Percept clips are those clips $c$ that gets stimulated by percepts $s$ according to a specific probability distribution $I(c|s)$, while action clips $a$ are clips that, if stimulated, trigger an action. One of the most important features in ECM is the possibility to have remembered or fictitious percepts ⓢ$ := \mu(s) \in \mu(S)$ or actions ⓐ . Fictitious or remembered percepts or actions are stored inside clips, as sequences. Each clip has a length $L \geq 1$, which means that $c$ is composed by of $(c^1, c^2, ..., c^L)$ where each $c^i \in \mu(S) \cup \mu(A)$. (In this article we will only use clips with $L=1$).</li><li>&nbsp;&nbsp;&nbsp; <b>edges</b> : are objects representing directed arc between clips (they have a starting clip and a receiving clip), and they contain data useful to the execution of the algorithm, such as weights, glowing tags, and emotion tags.</li><li>&nbsp;&nbsp;&nbsp; <b>emotions</b>: peace of data (called emotions tag) attached to the edge. Tags are represented as tuples&nbsp; $e = (e_1, e_2, ..., e_k)$ in the emotional space&nbsp; $E \equiv E_1 \times ... E_k = E, e_k = 1, ... |E_k| $. </li></ul><br />The weight of an edge between clip $c_i$ and $c_j$ is at time $t$ is stored in the weight matrix $h^t(c_i, c_j)$. The transition probabilities between clips are directly proportional to the weight of the edges. At the beginning of the execution of the algorithm, every percept clip is directly connected to every action clip. For the first part of our journey into PS, there will be no further connections between clips, and there are no further layers of clips (this will be generalized in the further sections). The reward function is $\Lambda : S \times A \to \mathbb{R}$.<br /><br /><br />The gist of PS is that a percept excites a percept clips, this excitation will start a random walk in the episodic memory, going through a chain of clips, eventually triggering an action clip. The transition probability between states of this stochastic process is obtained as a function of the weight matrix.<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-aw1ga6m0-pc/V2Zeo2jP_iI/AAAAAAAACOI/Ie-4S8cytj0j2g0zRfMUaMyY_HkY6d-hACLcB/s1600/Fig2.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="185" src="https://1.bp.blogspot.com/-aw1ga6m0-pc/V2Zeo2jP_iI/AAAAAAAACOI/Ie-4S8cytj0j2g0zRfMUaMyY_HkY6d-hACLcB/s320/Fig2.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 2 from [1] - EC memory: a network of clips in PS</td></tr></tbody></table><br /><br /><b>Emotions and reflection:</b><br />The state of emotional tags can change during the execution of the algorithm, according to a feedback function. It may seems that this is a similar concept of the reward function being used to update of the transition probability between clips, but it is not. The reward function is defined externally: <i>it is dependent on the external environment</i>. This function instead, is totally independent of it, and it is a parameter of the algorithm. Emotional tags can be thought as remembered rewards for previous actions. Seen from the purpose they serve, they are more similar to clips than to transition probability.<br /><br />Emotions represent a "higher abstraction" over the "lower level" of transition probability. We will use them to introduce the idea of reflection. When the reflection parameter $R$ is $&gt; 1$, the agent keeps computing the output, but in such a way that action clips are detached from their actual execution in the environment. This simulation is repeated until a certain condition on the emotion tags of the selected path has been satisfied, or it is stopped after $R -1 \in \mathbb{N}$ round of simulation into episodic memory. With a name that perfectly aid the intuition, $R$ is called reflection time for the agent. If the agent is unable to select a satisfying action, it executes in the environment one of the previously selected actions.<br /><br /><br />Emotion's space can be as complex as needed, but in the example, I found on literature it is limited to the funny space of $\{$ ☺ ,☹&nbsp; $\}$.<br /><br /><br />I stress that during reflection, action clips are only virtually excited, and they do not trigger any real action. It is thanks to this capability of the system that during the period of reflection an agent can project itself into "conceivable future situations", before triggering the real actuator, so to "think" their possible outcome. We could say that the emotions attached to the actions represent the state of belief of the agent for the right action given a specific percept.<br /><h4>&nbsp;</h4><h4>Afterglowing</h4>If the rewards are delayed (which is often the case in real world application), one can use afterglowing (<a href="https://en.wikipedia.org/wiki/Afterglow_%28drug_culture%29">lol</a>) : a technique for distributing rewards on recently used clips or edges. This is achieved by tagging each edge with a glowing factor $g$, whose value is set to $1$ each time it is used, and to $g^{t+1}(c_i, c_j) = g^t(c_i, c_j)(1- \eta)$ otherwise. Clip glowing (assign values to clips instead of edges) gives slightly different results on complex clip networks. The assumption behind afterglowing is that action in the past contribute less than recent actions for rewards we get (i.e., compare the importance for the victory between the first and the last move in a chess game). For more information take a look at [2].<br /><br /><br /><h3>PS without clip composition</h3><br />This section is used just to describe how PS works in its basic configuration, using only the tools described so far. The advanced features of the ECM memory are explained in the next sections.&nbsp; Here we assume that percept clips are directly connected to action clips, without any middle layer of clips.<br /><br /><br />Ladies and gentlemen let me introduce you to Projective Simulation algorithm!<br /><br /><ol><li>&nbsp;&nbsp;&nbsp; The input of the algorithm is a percept. A percept stimulates a percept clip.</li><li>&nbsp;&nbsp;&nbsp; The excitation of the percept clip start a stochastic process: a random walk on the network of clips. The initial clip of the walk is the the percept clip excited by the pecepts. The hopping probability at time $t$ is $p^{t}(s,a)$ and is initially uniform among all the clips. The random walk terminates once an action clip is reached. If the reflection parameter $R$ is set ($&gt;1$), and if the emotion attached to that action is negative, than it engages reflection, and start computing further random walks (i.e. samples from the random variable of the stationary probability distribution). This process&nbsp; is repeated at most $R-1$ times: until a boolean function $f : E \to \{true, false \}$is true(otherwise the last action is taken). Weights for the calculation of the hopping probability can be defined by the following policies:</li><ul><li>&nbsp;&nbsp;&nbsp; <b>standard function</b> $$p^{(t)}(c_i, c_j) = \frac{h^{(t)}(c_i, c_j)}{\sum_k h^{(t)}(c_i, c_k)} $$</li><li>&nbsp;&nbsp;&nbsp; <b>softmax function</b> $$p^{(t)}(c_i, c_j) = \frac{e^{h^{(t)}(c_i, c_j)}}{\sum_k e^{h^{(t)}(c_i, c_k)}} $$ (i.e. it gives higher probability to stringer edges - enhancing the exploitation in exploitation/exploitation paradigm)</li><li>&nbsp;&nbsp; $\epsilon$-<b>Greedy algorithm</b>, as in <a href="https://junedmunshi.wordpress.com/2012/03/30/how-to-implement-epsilon-greedy-strategy-policy/">classical RL</a>.</li></ul><li>&nbsp;&nbsp;&nbsp; Selected action is executed in the real world and the eventual reward is collected and taken into account. As we do in ML, while updating our transition probability, we should model the act of forgetting (i.e. giving less weight to lessons learned in the past and letting our agent learn from newer experience). To do that, we use the forgetting factor $\gamma$. Forgetting and hopping probability update (for rewarded and penalized edges) can be compressed in a single formula: $$h^{t+1}(s,a) -h^t(s,a) = - \gamma[g^t(s,a)-] + \lambda \delta(s,s^n)\delta(a,a^n) $$. Where $\delta$ is the Kroneker's delta, and $\lambda =\Lambda^t(s^t,a^t)$. The emotion tag associated with that action is changed according to the reward received. If the reward is positive, the emotion is set to 😄, otherwise is set to 😄. Note that in this is just a toy case, and the emotion space can be way more complex.</li></ol><br />Note that our formula the entries of the matrix $h(c_j,c_i)$ are always greater than 1.&nbsp; These steps are iterated on and on, mimicking the continuous iteration of an agent within its environment.<br /><br /><br />Basically, SP is a continuous interaction with the environment, where each step comprises a call to the memory of an agent. Each call is a sample over a stationary distribution of an irreducible, aperiodic, and irreversible Markov Chain over the clip's space. The states of the Markov Chain may evolve over time, according to the feedback received from the environment.<br /><br /><h3>Invasion Game</h3><br />To have a taste of PS in action, we will focus on some variations of a game called Invasion Game. It's not the aim of this post to dig into the application of PS, but the study of this game really helps intuition. <br /><br /><br />Imagine you have two robots facing each other across a fence with holes.<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v &lt;----attacker<br /><br />---&nbsp;&nbsp; ---&nbsp;&nbsp; ---&nbsp; ---&nbsp; ---<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ &lt;---- defender <br /><br /><br />The attacker have to cross the fence in one of the holes, while the defender has to block the attack moving to the hole the attacker wants to go, preventing him from crossing. At each round, before the attack, the attacker show a symbol which is consistent with the direction he wants to go. <br /><br /><br />The defender, who has no prior information on the meaning of the symbol, have to learn, while playing, what is the meaning of the symbols and block the right hole. If the defender is able to block one attempt, it gets a reward of $1$, otherwise, it gets $0$. After the rewards have been collected by the agent, the battle starts again, with the two robots facing each other. That's exactly what has been done in [1], where the defender was programmed with a PS algorithm. <br /><br /><br />Let's make the game formally fit our model:<br /><br />&nbsp;&nbsp;&nbsp; percepts: symbols shown by attacker: $ S \equiv S_1 = \{ \rightarrow, \leftarrow \}$ (attack right, attack left)<br />&nbsp;&nbsp;&nbsp; action space: $A \equiv A_1=&nbsp; \{ +, - \} $ (move right, move left)<br />&nbsp;&nbsp;&nbsp; emotions space: $\{$ ☺ ,☹&nbsp; $\}$<br /><br />To measure how good is the algorithm in playing this game, we use the blocking efficiency, it shows us what is the expected reward for our agent at time $t$. Since we are dealing with non-deterministic processes we expect to be something averaged, and we must take into account the non-determinism of (a) the percept we receive from the external world which may change over time and (b) the conditional probability of choosing the right action given a specific percept at a specific time. This whole concept is nicely subsumed into this formula:<br /><br /><br />$$r^t = \sum_{s \in S} P^t(s)P^t(a^*_s | s) $$<br /><br /><br />Where $P^t(s)$ is the probability of receiving the percept $s$ at time $t$ and $P^t(a^*_s | s)$ is the probability at time $t$ of selecting the rewarded action ($a^*$) given the percept $s$ has been received.<br /><br /><br />For the following graphs, blocking efficiency has been empirically calculated, averaging the results among 1000 matches (i.e. you will see fluctuations in the curves).<br /><br /><br /><h3>Basic version of PS in practice</h3><br />Imagine to train our agent to play Invasion Game, setting initially the reflection parameter at $R=1$, with percept clips directly connected to action clips. Needless to say, PS can play Invasion Game as many other RL algorithms. Here we are no interested in the learning capabilities of a PS agent, but instead, we will test the behavior of the defender in specific "exceptional cases". We will try to mess up the environment in two different ways, and see how our agent react.<br /><br /><br />The simplest mischief we can do to our robot is this: wait until it has learned to defend with high efficiency, and then change the meaning of the direction of the arrows (i.e.suddenly $\leftarrow$ means right and $\rightarrow$ means left). What happens to the blocking efficiency of our robot?<br /><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-GTUp7X2eM8I/V02QEYwqUII/AAAAAAAACMU/U7hDSmgwiUQcIOVSElR5IlOc4bPqe5dTACLcB/s1600/blockingEfficiency.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="261" src="https://2.bp.blogspot.com/-GTUp7X2eM8I/V02QEYwqUII/AAAAAAAACMU/U7hDSmgwiUQcIOVSElR5IlOc4bPqe5dTACLcB/s320/blockingEfficiency.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 5 from [1] - Blocking efficiency of the agent. The meaning of the arrows changed at time $t=250$.</td></tr></tbody></table><br />Here we clearly see that, when we change ($t=250$), each second curve is less steep than the first. That's because the agent has to forget what he has learned first, and then re-learn everything from scratch. This happens for 3 different $\gamma$ (the forgetting factor). Given the Bayesian structure of the algorithm itself, this is something we should expect: also other RL algorithm behave similarly.<br /><br /><br />Given this configuration of the game, there is another mischief we can do to our defender robot: expanding its percept space with edges of another color ( keeping the same direction of the arrows ). This would update our percept space to $S= S_1 \times S_2 = \{ \rightarrow, \leftarrow \} \times \{red, blue \}$. How does the efficiency of our agent evolve?<br /><ul></ul><h3></h3><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-w1qz7x5DFQI/V02QcJB9jNI/AAAAAAAACMY/Vgk-qvOsQ-0UT5Fy2-DabRTxZfIAqhV7ACKgB/s1600/twosymbols.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="249" src="https://3.bp.blogspot.com/-w1qz7x5DFQI/V02QcJB9jNI/AAAAAAAACMY/Vgk-qvOsQ-0UT5Fy2-DabRTxZfIAqhV7ACKgB/s320/twosymbols.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 6 from [1] - Blocking efficiency with arrows introducing arrows of different color at time $t=200$.</td></tr></tbody></table><br /><br />Ah ah. For an agent totally unaware of the semantic of an arrow, we would expect to re-learn the correct behavior from scratch, and that's exactly what we see from the two curves. It is the "proof" that from the robot's perspective, we are using totally different symbols.<br /><br />And what now if we turn reflection on? Given the same measure of efficiency we can plot results for $R=1$ and $R=2$ (without symbol modification):<br /><h3><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-3JbY2Er1ahI/V02QtnGhc4I/AAAAAAAACMg/ro5mSOhXEpYvMX4l78Za9IudEHFDhDeOgCLcB/s1600/reflection.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="253" src="https://2.bp.blogspot.com/-3JbY2Er1ahI/V02QtnGhc4I/AAAAAAAACMg/ro5mSOhXEpYvMX4l78Za9IudEHFDhDeOgCLcB/s320/reflection.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 7 from [1] - Blocking efficiency with 2 different Reflection's value.</td></tr></tbody></table></h3>Reflection has a concrete impact on the learning phase of an agent. And this is by itself a nice result. The structure of EC memory installed in the agent is<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-f2LMJWra3g4/V12B7sM_z9I/AAAAAAAACNk/o1hM8JecVeop39rqDFaMFyU6_KNUsqNJgCLcB/s1600/Fig4.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="216" src="https://3.bp.blogspot.com/-f2LMJWra3g4/V12B7sM_z9I/AAAAAAAACNk/o1hM8JecVeop39rqDFaMFyU6_KNUsqNJgCLcB/s320/Fig4.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 4 from [1] - The EC memory of the defending agent in Invasion Game.</td></tr></tbody></table><br /><br />We have just started exploring the feature of PS. Wouldn't we love if an "intelligent" agent can find some sort of similarities between the two arrows pointing in the similar direction, but with different colors? Yes! After all, isn't this our definition of creativity?<br /><br />So be surprised then, because this behavior is exactly what we get using two advanced feature of the ECM.&nbsp; Starting to be impressed? You should... :v<br /><br /><h3>Learning how to learn<b><span style="font-weight: normal;"> </span></b></h3>Mimicking what happen in biological brains, we can enhance our model of memory by adding new percept clips during the lifetime of an agent. These new percept clips can be connected at the same time to action clip (as before) but also to other percept clips. Practically this means that the walk on the graph could start from percept with other incoming edges from other percept clips.<br /><br /><br />The steps of the algorithm are similar to the previous case, but now we have to update the transition probability of all the edges in the sequence of clips which lead from the percept to the action. Without digging into the details (that you can find in [1][12]), these are the modified steps of the algorithm:<br /><br />&nbsp;&nbsp;&nbsp; The input of the algorithm is a percept. A percept stimulates a percept clip.<br />&nbsp;&nbsp;&nbsp; A random walk from the percept clip $s$ to an action clip $a$ select a sequence of memory clips $\Gamma$. The length of the sequence is called deliberation length. The length $D$ of the chain $(s, s^D)$ is called "deliberation length", and it is roughly "how long does it take to think". The probability for the walk to go from clip $c$ to clip $c'$ is proportional to the ratio between the weight of the edge from clip $c$ to clip $c'$ and the sum of all the weights of the edges starting from $c$. If $(s,a)$ is rewarded sufficiently, and if its emotion is suitable (i.e. 😄), the action is executed. Otherwise, this step is iterated to most other $R-1$ times, and then a random action is taken. <br />&nbsp;&nbsp;&nbsp; If the action is rewarded, also edges in the associative memory from $s$ to $a$ will be rewarded by a factor $K$ called growth rate of associative connections (direct connections of percept clips with action clip are increased by $1$, as usual). Forgetting factor works as usual, with the requirement that weights of the compositional sequences of clips (i.e. not direct sequences from percept clip to action clip) are dumped towards $K$.<br /><br /><br />Let's play again Invasion Game. This time, we will repeat the experiment of changing the color of the arrows shown by the attacker. We will have a slightly different EC memory, depicted in the image below. <br /><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-kZUWVWPiseY/V1iKhC3YFVI/AAAAAAAACNM/DTRHwv84r605bt2Ls9BCtI_3tTI4nYaWwCLcB/s1600/Fig12.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="https://4.bp.blogspot.com/-kZUWVWPiseY/V1iKhC3YFVI/AAAAAAAACNM/DTRHwv84r605bt2Ls9BCtI_3tTI4nYaWwCLcB/s320/Fig12.png" width="282" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 12 From [1] - Evolution of the ECM while learning</td></tr></tbody></table>In the picture, (a) is the initial state of the memory, (b) is the memory after it has been trained with red arrows (please note the slightly thick arc from the blue arrows to the red ones: its weight is $K$.), and (c) the associative memory in action.<br /><br /><br />This is an example of how a newly excited percept clip (blue arrow) could excite another clip in episodic memory (red arrow), from which strong links to specific action clips had been built-up by previous experience. This capability can be used to speed the learning time of an agent, as we see in the graph below. The agent has been trained for until $t=200$ to play with red arrows, and then the attacker switch to blue arrows.<span style="font-weight: normal;"><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-D_v-zebrNCg/V1hzkCmBF2I/AAAAAAAACM8/h9iAp3kc3rotPUNiODj8OfQMbNSoNM7PwCLcB/s1600/Fig11.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="252" src="https://4.bp.blogspot.com/-D_v-zebrNCg/V1hzkCmBF2I/AAAAAAAACM8/h9iAp3kc3rotPUNiODj8OfQMbNSoNM7PwCLcB/s320/Fig11.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 11 From [1] - The bigger the K, the steeper the learning curve.</td></tr></tbody></table></span><br /><br />This match our previous definition of intelligence: we would expect an intelligent agent to learn how to play faster with the new symbols, since their "semantics" (in terms of rewards) is already known for similar symbols. Our agent, in fact, knows already how to play! That's exactly what happens using EC memory with higher deliberation length.<br /><br />This structure resembles an associative <a href="https://en.wikipedia.org/wiki/Associative_memory_%28psychology%29">memory</a>, and this is an example of associative <a href="https://en.wikipedia.org/wiki/Learning#Associative_learning">learning</a>.<br /><i></i> <br /><h3>Combining actions </h3><br />We can generalize our model creating new clips by composing pre-existing ones. For instance, we can compose together two action clips. There are a few requirements from merging, though:<br /><br /><ol><li>&nbsp;&nbsp;&nbsp; Both action clips should be sufficiently rewarded for the same percept: there is a threshold level of reward for two actions to be considered sufficiently rewarded.</li><li>&nbsp;&nbsp;&nbsp; The actions are similar, e.g action vectors only differ in two components, and are semantically compatible (i.e. you cannot combine "jump" and "stand still" in your agent, or "go right" with "go left").</li><li>&nbsp;&nbsp;&nbsp; The newly composed action clip does not exist already.</li></ol><br />This feature is what allows us to do action clip compositions, which we will see applied in a 3D version of Invasion Game.<br /><br /><br />Now the attacker have to cross an imaginary grid-like plane, and the defender can move over the plane, so to block the attacker.<br /><br /><br />Our percept space is: $S \equiv S_1 = \{ \rightarrow, \leftarrow, \nearrow, \searrow, \nwarrow, \swarrow, \uparrow, \downarrow \}$<br /><br />Our action space $A \equiv A_1 \times A_2 = \{ (+, 0), (-, 0) \} \times \{ (0, +), (0, -) \} $, where each component of the tuple fix an axes, and the sign is ment to point the verse.<br /><br /><br />Beware, we will now give the partial reward to our agent if he can match half of the direction of the attacker. For instance, if the attacker decides to move in diagonal $\nearrow$, the defender gets partial rewards if it chooses one among up or right.<br /><br /><br />This time [1], the agent has first been trained only with attacks along the axis. When he is presented with attacks on the $\nearrow$ direction, he will soon realize that there are two action clips equally rewarded for that action, which are semantically compatible. So the agent might think it could merge two actions into one, by creating a new action clip which activates the two action in the real world simultaneously, and sees what happen. <br /><br /><br />This is what happens in his brain in terms of clips. The bigger the edge, the bigger is the transition probability.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://www.nature.com/article-assets/npg/srep/2012/120515/srep00400/images_hires/w926/srep00400-f16.jpg" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://www.nature.com/article-assets/npg/srep/2012/120515/srep00400/images_hires/w926/srep00400-f16.jpg" height="181" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 16 from [1] - Example of action clip composition where our agent learns to move in diagonal.</td></tr></tbody></table><br />Needless to say, our new favorite ML algorithm does not let us down, showing how the defender can discover new "behavior" which were not previously given. <br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-E0uegmaUYrg/V12CsWeeveI/AAAAAAAACNw/VX-um2I6UNQj8nEQ40CtP9it-AykRDPMwCLcB/s1600/Fig17.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="220" src="https://3.bp.blogspot.com/-E0uegmaUYrg/V12CsWeeveI/AAAAAAAACNw/VX-um2I6UNQj8nEQ40CtP9it-AykRDPMwCLcB/s320/Fig17.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig 17 from [1] - Agent's performance for the various threshold level of association.</td></tr></tbody></table><br />In the graph above, the agent has been trained for $t&lt;0$ (not shown) with only attacks along the axes, while for $t&gt;0$ the agent is faced with only attacks along the $\nearrow$ direction. As you can see, the partial reward is set to $1$, while the total reward for a diagonal move is set to $4$.<br /><h3>&nbsp;</h3><h3>Comparison with Reinforcement Learning algorithms</h3><h3></h3>PS has been compared to another algorithm of reinforcement learning in a recent thesis [2]. The comparison was on real implementations of games and other tasks.&nbsp; Java code can be found in&nbsp; [3]. Moreover, since the interface for the algorithm of PS and RL is very similar, a comparison of their respective computational complexity was possible [2]. Both algorithms, in fact, expose a function $getAction$ - the function that gives you an action given an input- and a function $getReward$ - which distribute rewards in the model.<br /><ul><li>The complexity of $getAction$ of both algorithms is $O(|A|)$, but goes to $O(|A|*R)$ if glowing or dumping are enabled.</li><li>$getAction$ can be implemented using the same selection function ($\epsilon$-Greedy, SoftMax, and the plain probability function).</li><li>For some games, the use of emotion has been useful.</li><li>Glowing can be compared to eligibility traces. The same concept for distributing delayed rewards on the previous action in RL.</li><li>The complexity of $getReward$ is more efficient in the RL case. </li><li>In&nbsp; a&nbsp; well-defined&nbsp; world,&nbsp; the&nbsp; RL algorithms are guaranteed to find an optimal policy[2], but PS seems to be more suitable in a more complex environment, where rules are unknown and subject to changes.</li></ul><br />There are two algorithms in literature that resemble PS: experience replay, and a dyna-algorithm. Those are "conceptually" similar, but with totally different structure, assumptions, complexity, and features.<br /><h3>&nbsp;</h3><h3>The quantum world</h3>he only way for an agent to exploit quantum mechanics to interact with a classical environment is to use quantum mechanics for internal state representation. To do that, we translate clips into vectors in a Hilbert space. Clips are a composite structure of remembered or fictitious percepts or action, and we will capture this composite structure by means of a tensor product of Hilbert spaces. The steps for running PS on a quantum machine are those:<br /><br /><ul><li>A classical percept $s \in S$ is translated into a state in the quantum memory of the agent. This state is described by the density operator $\rho(s)$.</li><li>The physical system will evolve according to an Hamiltonian (which we will specify later).</li><li>A quantum measure on this quantum system will lead us to a specific action.</li></ul>We define the probability of transition from a clip to another by the Born's rule: nonorthogonal vector/clips are connected by a&nbsp; probability $0 \leq p= \left| \langle c_i|c_j \rangle \right|^2 \leq 1$ that the jump of the excitation during the walk may occur. That's the natural choice of embedding probability in a quantum world, so to give raise to our beloved quantum interference. As you may imagine, the initial state could be a superposition of multiple initial states, and this might lead to a speedup.<br /><br /><br />Now the tough part: how to translate in the quantum physical word a conceptual thing such as a walk on a graph? The Hamiltonian for such operation is pretty complex and has been found here.<br /><br /><br />$$ H = \sum_{ \{ j,k \} \in E} \lambda_{jk}(\hat{c}_k^{\dagger}\hat{c}_{j} + \hat{c}_k \hat{c}^{\dagger}_j ) + \sum_{j \in V} \epsilon \hat{c}_j^{\dagger}\hat{c}_j&nbsp;&nbsp;&nbsp; $$<br /><br /><br />If you are curious about the operator $c$ and $c_j$, take a look at my previous blog post here: those are exactly the same operation used to probabilistiscally move the excitation along a chain of qubits.<br /><br /><br />However, there's a problem with this definition: our Hamiltonian describe the evolution of a reversible system: it means that the transition probability between two state is symmetric. While this quantum environment is perfect for undirected graphs, we have hard time modeling directed graphs. [1] We thus have to model a reversible, irreducible, and aperiodic Markov chain.<br /><br /><br />The quantum speedup, which has been showed in [11]&nbsp; to calculate reflection via the Groover's algorithm. But this is a whole new story worth another single blog post I will be glad to write in another post.<br /><br /><br /><br />Moreover, a recently, a broader class of graphs for which there is an exponential speedup of the hitting time of the Markov chain has been found. That's cool, since the core of our algorithm is a random walk on a graph-like structure, and the hitting time (in our case) is the average time for which the excitation goes from the first percept clip to the action. To date, we know that discrete quantum walks on hypercubes are exponentially faster on quantum computers, and this class of graph has been extended to <a href="https://en.wikipedia.org/wiki/Graph_embedding">embedded</a> hypercubes on certain graphs [12].<br /><br /><br /><h3></h3><h3>Parameters</h3><span style="font-weight: normal;">Straight from [2], we have:&nbsp;</span><br /><br /><table border="1" class="table table-bordered table-hover table-condensed"><tbody><tr><td>Parameter</td><td>Range</td><td>Field</td><td>Default</td><td>Explanation</td></tr><tr><td>Damping</td><td>$0 \leq \gamma \leq 1$</td><td>$\mathbb{R}$</td><td>0 or $\frac{1}{10}$</td><td>Forgetting factor</td></tr><tr><td>Reflection</td><td>$ 1 \leq R $</td><td>$\mathbb{N}$</td><td>1</td><td>Number of reflection cycle</td></tr><tr><td>Glowing</td><td>$ \eta \leq 1$</td><td>$\mathbb{R}$</td><td>1</td><td>Glowing factor for weighting rewards</td></tr><tr><td>Associative growth rate</td><td>$K &gt; 0$</td><td>$\mathbb{R}$</td><td>-</td><td>Growth rate of associative connections of composite paths</td></tr></tbody></table><h3>&nbsp;</h3><h3>Conclusions</h3>PS can be thought as a generalization of RL. The job of updating transition probability between edges can be done by Bayesian updating, which is basically a RL algorithm.<br /><br /><br />The ECM memory is an important part of the PS model. Is what allows an agent to do reflection, which is a kind simulation made by the agent of it's action in the world.&nbsp; Emotions and ECM are what allows the agent to detach from primary experience and to project themselves into conceivable situations (fictitious memory), without taking any real action.<br /><br /><br />A further generalization of PS scheme can be found in [10].&nbsp; <br /><br /><br />To sum everything up, learning in PS is achieved in three different ways:<br /><br /><ul><li>modifying via bayesian updating the transition probability between the clips of the network (aided by an RL algorithm)</li><li>creating new clips when new percepts are received</li><li>creating new clips from existing ones according to a compositional principle.</li></ul><br /><br />Much of the "magic" of this algorithm is embedded into our definition of clips, but it is something it must be specified case by case. That is because PS agents are defined on a more conceptual level as agents whose internal states represent episodic and compositional memory and whose deliberation comprises association-driven hops between memory sequences (the clips). [13]<br /><br /><br />I am not aware yet of any implementation in quipper or LiQI|&gt; of the algorithm. We could, in fact, write the Hamiltonian of the physical system and give it as an input to the GSE algorithm, and run our software on our favorite quantum programming language [5] [6]. GSE is an algorithm for simulating a physical system (given it's Hamiltonian) on a gate-based model of quantum computer, efficiently. There is already an implementation of GSE, based on the work of [4].<br /><br /><br />Speaking about simulating physics with computers,&nbsp; I built an Hamiltonian with my own bare hands, and you can play with it here!<br /><br />I would like to close this article with a quote [7] which I believe subsume the Zeitgeist among many scientists nowadays:<br /><i><br /></i><br /><div style="text-align: center;"><i>&nbsp;If we accept that free will is compatible with physical law, we also have to accept that it must be possible, in principle, to build a machine that would exhibit similar forms of freedom as the one we usually ascribe to humans and certain animals</i></div><br /><br />I do not claim copyright for any of the pictures in this post. They all belongs to the authors of [1]. <br /><br /><br />Ocio: I would appreciate if you can send me an email if you find any mistake. Feedback is always welcome, I want to improve! This post may get updated over time as I learn new things or I am not satisfied with my previous explanations.<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><br /></div><br /><iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/HDRXG125PmY/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/HDRXG125PmY?feature=player_embedded" width="320"></iframe><br /><br />Sybreed - God is an automation (piano cover by a random guy on youtube) <br /><h3></h3><h3><b><span style="font-weight: normal;">References</span></b></h3><br /><span style="font-weight: normal;">[1] Briegel, Hans J., and Gemma De las Cuevas. "Projective simulation for artificial intelligence." Scientific reports 2 (2012). - <a href="http://www.nature.com/articles/srep00400" target="_blank">http://www.nature.com/articles/srep00400&nbsp;</a></span><br /><span style="font-weight: normal;">[2] Bjerland, Øystein Førsund. "Projective Simulation compared to reinforcement learning" - <a href="http://bora.uib.no/bitstream/handle/1956/10391/135269761.pdf?sequence=1&amp;isAllowed=y" target="_blank">http://bora.uib.no/bitstream/handle/1956/10391/135269761.pdf?sequence=1&amp;isAllowed=y </a></span><br />[3] Java Implementation of PS algorithm by Bjerland, Øystein Førsund - <a href="https://bitbucket.org/mroystein/projectivesimulation">https://bitbucket.org/mroystein/projectivesimulation</a><br />[4] Simulation of Electronic Structure Hamiltonians Using Quantum Computers<br />James D. Whitfield, Jacob Biamonte, Alán Aspuru-Guzik: <a href="http://arxiv.org/abs/1001.3855">http://arxiv.org/abs/1001.3855</a><br />[5] Green, Alexander S., et al. "An introduction to quantum programming in Quipper." Reversible Computation. Springer Berlin Heidelberg, 2013. 110-124. <a href="http://arxiv.org/pdf/1304.5485v1.pdf">http://arxiv.org/pdf/1304.5485v1.pdf</a> <br />[6] Liquid User Manual : <a href="https://msr-quarc.github.io/Liquid/LIQUiD.pdf">https://msr-quarc.github.io/Liquid/LIQUiD.pdf</a><br />[7] Briegel, Hans J. "On creative machines and the physical origins of freedom." Scientific reports 2 (2012). - <a href="http://www.nature.com/articles/srep00522" target="_blank">http://www.nature.com/articles/srep00522&nbsp;</a><br />[8] Kandel, Eric R. "The molecular biology of memory storage: a dialogue between genes and synapses." Science 294.5544 (2001): 1030-1038. <a href="http://www.ncbi.nlm.nih.gov/pubmed/11691980" target="_blank">http://www.ncbi.nlm.nih.gov/pubmed/11691980</a><br /><span style="color: red;"><span style="color: #444444;">[9] Antonov, Igor, et al. "Activity-dependent presynaptic facilitation and Hebbian LTP are both required and interact during classical conditioning in Aplysia." Neuron 37.1 (2003): 135-147</span>.&nbsp;</span><br />[10] <a href="http://arxiv.org/pdf/1504.02247v1.pdf" target="_blank">Projective simulation with generalization</a>: Alexey&nbsp; A.&nbsp; Melnikov, Adi&nbsp; Makmal,&nbsp; Vedran&nbsp; Dunjko, and&nbsp; Hans&nbsp; J.&nbsp; Briegel.<br />[11] Paparo, Giuseppe Davide, et al. "Quantum speedup for active learning agents." Physical Review X 4.3 (2014): 031002. <a href="http://journals.aps.org/prx/abstract/10.1103/PhysRevX.4.031002" target="_blank">http://journals.aps.org/prx/abstract/10.1103/PhysRevX.4.031002</a><br />[12]&nbsp; Makmal, Adi, et al. "Quantum walks on embedded hypercubes." Physical Review A 90.2 (2014): 022314. <a href="https://arxiv.org/pdf/1309.5253.pdf">https://arxiv.org/pdf/1309.5253.pdf</a><br />[13] Hines, Andrew P., and P. C. E. Stamp. "Quantum walks, quantum gates, and quantum computers." Physical Review A 75.6 (2007): 062321. <a href="http://arxiv.org/abs/quant-ph/0701088">http://arxiv.org/abs/quant-ph/0701088</a>&nbsp; 
